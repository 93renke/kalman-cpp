<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>kalman-cpp: kalman-cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">kalman-cpp
   </div>
   <div id="projectbrief">Implementation of Kalman Filter and extended Kalman filter in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">kalman-cpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="linear-kalman"></a>
Kalman filter for a linear system</h1>
<h2><a class="anchor" id="definition_kf"></a>
Definition</h2>
<p>A linear system is described by: </p><p class="formulaDsp">
\[x_k = Ax_{k-1} + Bu_{k-1} + v_{k-1}\]
</p>
 <p class="formulaDsp">
\[z_k = Hx_k + w_k\]
</p>
<p> where:<br />
 \(v\) is the process noise (Gaussian with covariance Q)<br />
 \(w\) is the measurement noise (Gaussian with covariance R)<br />
 \(A\) is the system matrix<br />
 \(B\) is the input matrix<br />
 \(H\) is the output matrix<br />
 \(x\) is the state vector<br />
 \(z\) is the output vector<br />
 \(u\) is the input vector<br />
<br />
The noise covariance matrices must follow these conditions:<br />
 </p><p class="formulaDsp">
\[Q = Q^T\]
</p>
 <p class="formulaDsp">
\[R = R^T\]
</p>
<h2><a class="anchor" id="example_kf"></a>
Example</h2>
<p>An example provided in <a class="el" href="main1_8cpp.html" title="Example for the Kalman filter. ">main1.cpp</a> solves <a href="http://www.mathworks.com/matlabcentral/fileexchange/18465-learning-the-kalman-filter-in-simulink-v2-1/content/html/runkalmanfilter.html">the car voltmeter problem</a> using this library. The system model for this problem is governed by:</p>
<p class="formulaDsp">
\[x_k = 12 + v_{k-1}\]
</p>
 <p class="formulaDsp">
\[z_k = x_k + w_á¸³\]
</p>
<p>Therefore, we can summarize: \(A = 0\), \(B = 1\), \(H = 1\), \(u = 12\), \(x_0 = 12\), \(Q=4\), and \(R=4\). These values are the put into the following lines of codes.</p>
<div class="fragment"><div class="line">mat A(1,1), B(1,1), H(1,1), Q(1,1), R(1,1);</div><div class="line">colvec u(1);  </div><div class="line"></div><div class="line">A &lt;&lt; 0;</div><div class="line">B &lt;&lt; 1;</div><div class="line">Q &lt;&lt; 4;</div><div class="line">H &lt;&lt; 1;</div><div class="line">R &lt;&lt; 4;</div><div class="line">u &lt;&lt; 12.0;</div></div><!-- fragment --><p>The first line of the code above is used to create all necessary matrices with correct dimensions. All matrix operations use the Armadillo library. Please refer to the Armadillo documentation on how to create a matrix and set its element values. The next step is to create an instance of class <a class="el" href="class_k_f.html" title="Implemetation of the Kalman filter. ">KF</a> and initialize it with the newly created \(A\), \(B\), \(Q\), \(H\), and \(R\).</p>
<div class="fragment"><div class="line"><a class="code" href="class_k_f.html">KF</a> kalman;</div><div class="line">kalman.<a class="code" href="class_k_f.html#a890367dd9a8888a2ea8bda296b6128dd">InitSystem</a>(A, B, H, Q, R);</div></div><!-- fragment --><p>The last step is to run the Kalman iteratively as shown in the codes below.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 100; k++) {</div><div class="line">  kalman.<a class="code" href="class_k_f.html#acc63e676e77b8a6b1ccbb88dec545d99">Kalmanf</a>(u);</div><div class="line">  </div><div class="line">  <span class="comment">/* The rest of the code ... */</span></div><div class="line">}</div></div><!-- fragment --><div class="image">
<img src="ex1.png" alt="ex1.png"/>
</div>
<h1><a class="anchor" id="non-linear-kalman"></a>
Extended Kalman filter for a nonlinear system</h1>
<h2><a class="anchor" id="definition_ekf"></a>
Definition</h2>
<p>A non-linear system is described by: </p><p class="formulaDsp">
\[x_k = f(x_{k-1}, u_{k-1}, k) + v_{k-1}\]
</p>
 <p class="formulaDsp">
\[z_k = h(x_k, u_k, k) + w_k\]
</p>
<p> where:<br />
 \(f\) is the dynamic model of the system<br />
 \(h\) is the measurement model of the system<br />
 \(v\) is the process noise (Gaussian with covariance Q)<br />
 \(w\) is the measurement noise (Gaussian with covariance R)<br />
 \(x\) is the state vector<br />
 \(z\) is the output vector<br />
 \(u\) is the input vector<br />
<br />
The noise covariance matrices must follow these conditions:<br />
 </p><p class="formulaDsp">
\[Q = Q^T\]
</p>
 <p class="formulaDsp">
\[R = R^T\]
</p>
<h2><a class="anchor" id="example_ekf"></a>
Example</h2>
<p>Here, <a class="el" href="main4_8cpp.html" title="Example for the extended Kalman filter. ">main4.cpp</a> is taken as an example which is adapted from this <a href="http://ch.mathworks.com/matlabcentral/fileexchange/38302-kalman-filter-package/content//Kalman%20Filter%20Package/Examples/ExtendedKalmanFilterDemo.m">MATLAB Central page.</a> The nonlinear system is described as:</p>
<p class="formulaDsp">
\[ f = \begin{bmatrix} sin(x_2(k-1))(k-1) \\ x_2(k-1) \end{bmatrix} \]
</p>
 <p class="formulaDsp">
\[ h = \begin{bmatrix} x_1(k) \\ x_2(k) \end{bmatrix} \]
</p>
 <p class="formulaDsp">
\[ x_0 = \begin{bmatrix} 0 \\ \frac{1 \pi}{500} \end{bmatrix}\]
</p>
<p>Class <a class="el" href="class_e_k_f.html" title="Implemetation of the extended Kalman filter. This class needs to be derived. ">EKF</a> needs to be derived to allow flexible implementation of the dynamic model and the measurement model of the system .</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyEKF: <span class="keyword">public</span> <a class="code" href="class_e_k_f.html">EKF</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:  </div><div class="line">  <span class="keyword">virtual</span> colvec <a class="code" href="class_e_k_f.html#aa52d1de79e221c5ea2febdb7de0bf82a">f</a>(<span class="keyword">const</span> colvec&amp; x, <span class="keyword">const</span> colvec&amp; u, <span class="keyword">const</span> <span class="keywordtype">int</span> k) {</div><div class="line">    colvec xk(nOutputs_);</div><div class="line">    xk(0) = sin(x(1) * k);</div><div class="line">    xk(1) = x(1);</div><div class="line">    <span class="keywordflow">return</span> xk;</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keyword">virtual</span> colvec <a class="code" href="class_e_k_f.html#ab8058b1f4e42f075a99d8d1e8bc59441">h</a>(<span class="keyword">const</span> colvec&amp; x, <span class="keyword">const</span> colvec&amp; u, <span class="keyword">const</span> <span class="keywordtype">int</span> k) {</div><div class="line">    colvec zk(nOutputs_);</div><div class="line">    zk(0) = x(0);</div><div class="line">    zk(1) = x(1);</div><div class="line">    <span class="keywordflow">return</span> zk;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>The following steps are similiar with the previous example as in the linear Kalman filter. We start by defining the number of states and outputs, then followed by creating matrix Q and R. An instance of class <a class="el" href="class_e_k_f.html" title="Implemetation of the extended Kalman filter. This class needs to be derived. ">EKF</a> is created afterward and the states are initialized.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> n_states = 2;</div><div class="line"><span class="keywordtype">int</span> n_outputs = 2;</div><div class="line">mat Q(2, 2);</div><div class="line">mat R(2, 2);</div><div class="line"></div><div class="line">Q &lt;&lt; 0.001 &lt;&lt; 0    &lt;&lt; endr</div><div class="line">  &lt;&lt; 0     &lt;&lt; 0    &lt;&lt; endr;</div><div class="line"></div><div class="line">R &lt;&lt; 0.1   &lt;&lt; 0    &lt;&lt; endr</div><div class="line">  &lt;&lt;   0   &lt;&lt; 0.01 &lt;&lt; endr;</div><div class="line"></div><div class="line">colvec x0(2);</div><div class="line">x0 &lt;&lt; 0 &lt;&lt; 3 * M_PI / 500;</div><div class="line"></div><div class="line">colvec u;</div><div class="line"></div><div class="line"><span class="comment">// No inputs</span></div><div class="line">u = u.zeros(); </div><div class="line"></div><div class="line">MyEKF myekf;</div><div class="line">myekf.InitSystem(n_states, n_outputs, Q, R);</div><div class="line">myekf.InitSystemState(x0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 1000; k ++) {</div><div class="line">  myekf.EKalmanf(u, k);</div><div class="line"></div><div class="line">  colvec *x = myekf.GetCurentState();</div><div class="line">  colvec *x_m = myekf.GetCurentEstimatedState();</div><div class="line">  colvec *z = myekf.GetCurentOutput();</div><div class="line"> </div><div class="line">  <span class="comment">/* The resst of the code ... */</span></div><div class="line">}</div></div><!-- fragment --><div class="image">
<img src="ex4.png" alt="ex4.png"/>
</div>
<h1><a class="anchor" id="practical-application"></a>
Practical application: Using Kalman filter for smoothing noisy measurement data</h1>
<p>The examples we have so far are theoritical. Very often what we would like to do is simply to reduce noise from preacquired measurement data. There are several reason why we want to use Kalman filter. For example, the noise has very wide spectrum, thus, using frequency based filter hurts the data.</p>
<p>In principal, there are 2 scenarios of using the Kalman filter. The first scenario is by first simulating the system as shown in the figure below. In this scenario, we only need to supply \(u_k\) to the Kalman filter function. The Kalman filter will give us 4 outputs: \(x_k\), \(z_k\), \(\hat{x}_k\), and \(\hat{z}_k\). \(x_k\) and \(z_k\) are called the true system states and the true system outputs, respectvely. They are noisy. \(\hat{x}_k\), and \(\hat{z}_k\) are called the estimated system states and the estimated system outputs, respectively. They are filtered.</p>
<p>The function prototype for this scenario can be written as: [ \(x_k\), \(z_k\), \(\hat{x}_k\), \(\hat{z}_k\)] = function kalmanf( \(u_k\))</p>
<div class="image">
<img src="Kalman_concept1.jpg" alt="Kalman_concept1.jpg"/>
</div>
<p>The second scenario is used when the measurements are availble. Thus, simulating the system becomes unnecessary. In this scenario, we need to supply \(z_k\) and \(u_k\) to the kalman filter function. The Kalman filter will give us 2 outputs: \(\hat{x}_k\) (the estimated system sates) and \(\hat{z}_k\) (the estimated system outputs).</p>
<p>The function prototype for this scenario can be written as: [ \(\hat{x}_k\), \(\hat{z}_k\)] = function kalmanf( \(z_k\), \(u_k\))</p>
<div class="image">
<img src="Kalman_concept2.jpg" alt="Kalman_concept2.jpg"/>
</div>
<p>The second scenario is useful for smoothing noisy measurment data. However, both scenarios are availabe in this library.</p>
<h2><a class="anchor" id="practical_example"></a>
Example</h2>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 15 2017 21:39:20 for kalman-cpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
